# Prepare scRNAseq MAGMA signatures
# use scale_mat_1 to normalize pvalue generated by LDSC method
# scale_func_1: zscore --> pvalue--> normalized pvalue. 
#############################################################################################
# step1. import zscore
#############################################################################################

setwd("/projects/abv/users/olivamx2/Projects/AD/reproduce_fanying/magma/results/AD_HCA_scanpy_output")

#for 14 clusters:
zscore <- read.csv("14_clusters_AD_Lesion_vs_HC_DP/skin_score.csv")
input_name <- "LS_vs_H_14_clusters_DiseaseProgression"

#for 42 clusters:
zscore <- read.csv("42_clusters_AD_Lesion_vs_HC_DP/skin_score.csv")
input_name <- "LS_vs_H_42_clusters_DiseaseProgression"



head(zscore)
rownames(zscore) <- zscore$X
zscore <- zscore[ , -1]
dim(zscore)
zscore_mat <- as.matrix(zscore)
dim(zscore_mat) 
#[1] 33538    38
sample_names <- colnames(zscore)


# change pvalue into one-sided p-value
pvalue_mat <- apply(zscore_mat, 2, 
                    function(x) pnorm((x), mean=0, sd=1, lower.tail=F))

# do log transformation with pvalue mat
pvalue_log_mat <- apply(pvalue_mat, 2, function(x) -2*log(x))
quantile(pvalue_log_mat)

# do min-max normalization:
scale_func_1 <- function(input) {
  if(max(input) < -2*log(1e-8)) {
    max_value=-2*log(1e-8)
    scaled_output <- (input-min(input, na.rm = T))/(max_value -min(input, na.rm = T))
    scaled_output[is.na(scaled_output)] <- 0
  } else {
    input[which(input >=-2*log(1e-8))] <- -2*log(1e-8)
    max_value=-2*log(1e-8)
    scaled_output <- (input-min(input, na.rm = T))/(max_value -min(input, na.rm = T))
    scaled_output[is.na(scaled_output)] <- 0
  }
  
  return(scaled_output)
}

#scale_func_2 <- function(input) {
#  if(max(input)==Inf & max(input[!is.infinite(input)]) < -2*log(1e-8)) {
#    scaled_output <- rep(0, length(input))
#    scaled_output[which(is.infinite(input))] <- 1
#  } else if(max(input) < -2*log(1e-8)) {
#    max_value=-2*log(1e-8)
#    scaled_output <- (input-min(input, na.rm = T))/(max_value -min(input, na.rm = T))
#    scaled_output[is.na(scaled_output)] <- 0
#  } else {
#    max_value=max(input[!is.infinite(input)])
#    tmp <- max(input[!is.infinite(input)])
#    input[is.infinite(input)] <- tmp
#    scaled_output <- (input-min(input, na.rm = T))/(max_value -min(input, na.rm = T))
#    scaled_output[is.na(scaled_output)] <- 0
#  }
#  return(scaled_output)
#}

scaled_mat_1 <- apply(pvalue_log_mat, 2, function(x) scale_func_1(x))

#scaled_mat_2 <- apply(pvalue_log_mat, 2, function(x) scale_func_2(x)) #across genes
scaled_mat=scaled_mat_1
scaled_mat[which(rownames(scaled_mat)=="KRT16"),]

#############################################################################################
# step2. Prepare MAGMA signature
#############################################################################################
scaled_mat <- as.data.frame(scaled_mat)
scaled_mat$gene <- rownames(scaled_mat)

input=scaled_mat

gene_loc <- read.table("/projects/abv/users/tangfx1/TOOLS/magma_data/NCBI37.3/NCBI37.3.gene.loc", stringsAsFactors=F,header=F)

gene_loc_reorder <- gene_loc[match(input$gene, gene_loc$V6),]
dim(input)
#[1] 33538    39
dim(gene_loc_reorder)
#[1] 33538     6
dim(na.omit(gene_loc_reorder))
#[1] 18496     6

input$gene_ID <- gene_loc_reorder$V1
input_clean <- na.omit(input)
dim(input_clean)
#[1] 18496    40

output <- input_clean[, c("gene_ID", sample_names)]
colnames(output)[1] <- "GENE"
head(output)

write.table(output, paste0("/projects/abv/users/olivamx2/Projects/AD/reproduce_fanying/magma/results/markers_continuous_values/AD_HCA_skin_", input_name, "_signature_MAGMA.txt"), quote = F, col.names = T, row.names = F)

head(output)

